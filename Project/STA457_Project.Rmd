---
title: "STA457 Project"
author: "Xing Yu Wang"
date: "2025-03-29"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", out.width = "75%")
```

```{r, message=FALSE}
library(dplyr)
library(tidyverse)
library(readr)
library(lubridate)
library(forecast)
library(astsa)
library(tseries)
library(mgcv)
library(Metrics)
library(ggplot2)
library(xgboost)
# library(XGBClassifier)
library(rugarch)
library(tibble)
library(xts)
```

# 1. EDA
```{r}
price = read.csv("./Daily Prices_ICCO.csv")
weather = read.csv("./Ghana_data.csv")
USD_GHS_Historical_Data = read.csv("./USD_GHS Historical Data.csv")
```

## 1.1 Clean Data
```{r}
weather <- weather |> dplyr::select(DATE, TAVG)
exchangerate <- USD_GHS_Historical_Data |> dplyr::select(Date, Price)
```

```{r}
colnames(price)[colnames(price) == 'ICCO.daily.price..US..tonne.'] <- 'Daily_Price'
colnames(weather)[colnames(weather) == 'DATE'] <- 'Date'
colnames(weather)[colnames(weather) == 'TAVG'] <- 'Avg_Temp'
colnames(exchangerate)[colnames(exchangerate) == 'Price'] <- 'exchange_rate'
```

## 1.2 Check duplicated values
```{r}
price |> group_by(Date) |> filter(n() > 1) |> ungroup()
```

```{r}
price <- price |> filter(!(Date == "31/01/2024" & Daily_Price == "10,888.05"))
price <- price |> filter(!(Date == "30/01/2024" & Daily_Price == "10,676.42"))
price <- distinct(price)
```

## 1.3 Convert to Time Series Data
### 1.3.1 price Dataset
```{r}
price$Date <- as.Date(price$Date, format="%d/%m/%Y")
price$Daily_Price <- as.numeric(gsub(",", "", price$Daily_Price))
price_month <- price |> mutate(Time = floor_date(Date, "month")) |> group_by(Time) |> 
  summarise(month_Price = mean(Daily_Price, na.rm = TRUE)) |> ungroup()
```

```{r}
summary(price)
```

```{r}
price_ts <- ts(price_month$month_Price, start = c(1994, 11), end = c(2024, 11), frequency = 12)
```

```{r}
plot(price_ts, main="Monthly Price Time Series", ylab="Price", xlab="Time")
```

```{r}
acf2(price_ts, 50)
```

```{r}
ndiffs(price_ts)
```

```{r}
price_month$price_log <- log(price_month$month_Price)
adf.test(price_month$price_log)
```

```{r}
acf2(price_month$price_log, 50)
```

Hence, we want to difference the price data.

```{r}
diff_log_price = diff(price_month$price_log)
ts.plot(diff_log_price, main = "Log Differenced Price Data", ylab = "Log Differenced Price")
```

```{r}
adf.test(diff_log_price)
```

```{r}
acf2(diff_log_price, 50)
```

### 1.3.2 ghana Dataset
```{r}
weather$Date <- as.Date(weather$Date)
weather$Avg_Temp <- as.numeric(gsub("", "", weather$Avg_Temp))
weather_month <- weather |> mutate(Time = floor_date(Date, "month")) |> group_by(Time) |> 
  summarise(Avg_Temp = mean(Avg_Temp, na.rm = TRUE)) |> ungroup()
```

```{r}
summary(weather_month)
```

```{r}
weather_ts <- ts(weather_month$Avg_Temp, start = c(1994, 11), end = c(2024, 11), frequency = 12)
```

```{r}
ts.plot(weather_ts, main="Monthly Average Temperature Time Series", ylab="Temperature", xlab="Time")
```

### 1.3.3 exchange Data
```{r}
exchangerate$Date <- as.Date(exchangerate$Date)
exchangerate$exchange_rate <- as.numeric(gsub("", "", exchangerate$exchange_rate))
rate_month <- exchangerate |> mutate(Time = floor_date(Date, "month")) |> group_by(Time) |> 
  summarise(exchange_rate = mean(exchange_rate, na.rm = TRUE)) |> ungroup()
```

```{r}
summary(exchangerate)
```

```{r}
rate_ts <- ts(rate_month$exchange_rate, start = c(1994, 11), end = c(2024, 11), frequency = 12)
```

```{r}
ts.plot(rate_ts, main="Monthly Average Exchange Rate Time Series", ylab="Exchange Rate (USD/GHS)", xlab="Time")
```

```{r}
par(mfrow=c(3,1), mar = c(3, 4, 2, 2))
# price
plot(price_ts, main="Monthly Price Time Series", ylab="Price", xlab="Time")
#temperature
ts.plot(weather_ts, main="Monthly Average Temperature Time Series", ylab="Temperature", xlab="Time")
# exchange rate
ts.plot(rate_ts, main="Monthly Average Exchange Rate Time Series", ylab="Exchange Rate (USD/GHS)", xlab="Time")
```

## 1.4 Time series plots for data
```{r}
ggtsdisplay(price_ts, main="Time series plot for Monthly World Cocoa Price")
```

```{r}
ggtsdisplay(weather_ts, main="Time series plot for Monthly Average Temperature")
```

```{r}
ggtsdisplay(rate_ts, main="Time series plot for Monthly Average Exchange Rate(USD/GHS)")
```

```{r}
par(mfrow=c(3,1), mar = c(3, 4, 2, 2))
# price
plot(price_ts, main="Monthly Price Time Series", ylab="Price", xlab="Time")
#temperature
ts.plot(weather_ts, main="Monthly Average Temperature Time Series", ylab="Temperature", xlab="Time")
# exchange rate
ts.plot(rate_ts, main="Monthly Average Exchange Rate Time Series", ylab="Exchange Rate (USD/GHS)", xlab="Time")
```
## 1.5 Combine and Split data
```{r}
data <- price_month |> left_join(weather_month, by = "Time") |> left_join(rate_month, by = "Time")
data <- data |> mutate(log_price = log(month_Price), diff_log_price = 
                         c(NA, diff(price_month$price_log))) |> drop_na()
data <- data |> dplyr::select(Time, Avg_Temp, exchange_rate, diff_log_price, log_price, month_Price)

data$Time <- as.Date(data$Time)
```

```{r}
plot(data$Avg_Temp, data$month_Price, xlab = "Monthly Price", ylab = "Average Temperature", 
     main = "Daily Price vs. Avg Temperature")
pairs(data[, c("month_Price", "Avg_Temp", "exchange_rate")])
```


```{r}
data <- data[order(data$Time), ]
cutoff <- floor(0.7 * nrow(data))
trainSet <- data[1:cutoff, ]
testSet <- data[(cutoff+1):nrow(data), ]
```

```{r}
data_train_ts <- ts(trainSet$diff_log_price, frequency = 12)
```

## 1.6 Stationarity check and Decomposition
```{r}
adf.test(data$month_Price)
```

```{r}
adf.test(data$log_price)
```


```{r}
adf.test(data$diff_log_price)
```

Since only the diff_log_price is stationary, we choose differenced monthly log price when fitting the model.

```{r}
diff_price_ts <- ts(data$diff_log_price, frequency = 12)
autoplot(decompose(diff_price_ts, type="additive")) +
  ggtitle("Decomposition of Differenced Log Price Time Series") +
  theme_minimal()
```


# 2. Method
## 2.1 ETS Model
ETS is a purely univariate model and cannot directly handle external regressors.

### 2.1.1 Fit Model
```{r}
ets_model <- ets(data_train_ts, model = "ANA")
ets_zmodel <- ets(data_train_ts, model = "ZZZ") # Automatically selects best model
summary(ets_model)
summary(ets_zmodel)
```

```{r}
plot(ets_model)
```

### 2.1.2 Forecasting and Plotting
```{r}
# Plot using log differenced price
data_test_ts <- ts(testSet$diff_log_price, start = end(data_train_ts) + c(0,1), 
                   frequency = 12)

h <- nrow(testSet)
forecast_ets <- forecast(ets_model, h = h)

autoplot(forecast_ets) + autolayer(data_test_ts, series = "Actual", color = "red")
```
The red line is the observed actual values. The forecasted values are the central blue line within the blue shaded prediction intervals.

```{r}
last_log_price <- tail(trainSet$log_price, 1)

# Convert back to actual price
forecasted_price <- exp(cumsum(forecast_ets$mean) + last_log_price)

actual_price <- exp(testSet$log_price)
```

```{r}
data_test_ts <- ts(testSet$diff_log_price, start = end(data_train_ts) + c(0,1), 
                   frequency = 12)

forecast_ets_ts <- ts(forecasted_price, start = start(data_test_ts), frequency = 12)
actual_ets_ts <- ts(actual_price, start = start(data_test_ts), frequency = 12)
```

```{r}
# Plot using actual price
autoplot(forecast_ets_ts, series = "Predicted") + 
  autolayer(actual_ets_ts, series = "Actual", color = "blue") +
  ggtitle("Forecast vs Actual Prices") +
  ylab("Price") +
  xlab("Time") +
  theme_minimal()
```
```{r}
checkresiduals(ets_model)
checkresiduals(ets_zmodel)
```

## 2.2 ARIMAX Model

Recall that in Section 1.3.1, we have tested the acf and adf.test, and determined that we would be using the differenced price data. To fit the trainset, we evaluate p and q for ARIMA model.

```{r}
adf.test(trainSet$log_price)
```

Next, we check if applying 1st differencing is good enough
```{r}
adf.test(diff(trainSet$month_Price))
```
P-value is smaller than 0.01 for differenced log price, and we are

```{r}
acf2(trainSet$diff_log_price)
```

### 2.2.1 Fit ARIMAX Model
```{r}
xreg_matrix <- cbind(trainSet$Avg_Temp, trainSet$exchange_rate)
colnames(xreg_matrix) <- c("Avg_Temp", "exchange_rate")
arimax_model <- Arima(trainSet$log_price, order=c(2,1,3), xreg = xreg_matrix)
summary(arimax_model)
```

```{r}
p <- 0:10
q <- 0:10
aic.arimax <- matrix(0, length(p), length(q)) 
for (i in 1:length(p)) {
  for (j in 1:length(q)) {
      modij = arima(trainSet$log_price, order = c(p[i], 1, q[j]), method = "ML", xreg=xreg_matrix)
      aic.arimax[i, j] = AIC(modij)
  }
}

j.arimax <- ceiling(which.min(aic.arimax) / length(p))
i.arimax <- which.min(aic.arimax) - (j.arimax-1)*length(p)
sprintf("Selected order for ARIMA: p = %d, q = %d", p[i.arimax], q[j.arimax])
```


```{r}
AIC(arimax_model)
```

```{r}
checkresiduals(arimax_model)
```

```{r}
qqnorm(arimax_model$residuals)
qqline(arimax_model$residuals, col="red")
```

Fail to reject $H_0$, hence residuals of this plot do not show significant autocorrelation.
- QQ-plot shows: ....
- ACF shows: ...
- Residuals shows: ...

```{r}
arimax_train_ts <- ts(trainSet$log_price, start = start(min(trainSet$Time)), frequency = 12)
arimax_fitted_ts <- ts(fitted(arimax_model), start = start(min(trainSet$Time)), frequency = 12)
plot(arimax_train_ts, type='l', col='black', main="ARIMAX: Train Set Log Prices vs Fitted", 
     ylab="Log Price", xlab="Time")
lines(arimax_fitted_ts, col='red')
```
The ARIMAX model fit the trainSet very accurately.

### 2.2.2 Forecasting With ARIMAX Model
Next we try to fit this ARIMAX model to testing set.
```{r}
forecast_arimax_xreg <- cbind(testSet$Avg_Temp, testSet$exchange_rate)
colnames(forecast_arimax_xreg) <- c("Avg_Temp", "exchange_rate")
forecast_arimax <- forecast(arimax_model, xreg=forecast_arimax_xreg, h=nrow(testSet))
```

Then we convert the log prediction back to original price.

```{r}
start_year <- format(min(testSet$Time), "%Y")
start_month <- format(min(testSet$Time), "%m")
start_arimax_test = c(as.numeric(start_year), as.numeric(start_month))

actual_price_arimax <- testSet$month_Price
forecasted_price_arimax <- exp(forecast_arimax$mean)
forecasted_arimax_lower95 <- exp(forecast_arimax$lower[,2])
forecasted_arimax_lower80 <- exp(forecast_arimax$lower[,1])
forecasted_arimax_upper95 <- exp(forecast_arimax$upper[,2])
forecasted_arimax_upper80 <- exp(forecast_arimax$upper[,1])

actual_arimax_ts <- ts(actual_price_arimax, start = start_arimax_test, frequency = 12)
forecast_arimax_ts <- ts(forecasted_price_arimax, start = start_arimax_test, frequency = 12)
forecasted_arimax_lower80_ts <- ts(forecasted_arimax_lower80, start = start_arimax_test, frequency = 12)
forecasted_arimax_lower95_ts <- ts(forecasted_arimax_lower95, start = start_arimax_test, frequency = 12)
forecasted_arimax_upper80_ts <- ts(forecasted_arimax_upper80, start = start_arimax_test, frequency = 12)
forecasted_arimax_upper95_ts <- ts(forecasted_arimax_upper95, start = start_arimax_test, frequency = 12)


# Plot with proper transformation
autoplot(actual_arimax_ts, series="Actual Price") +
  autolayer(forecast_arimax_ts, series="Forecasted Price") +
  autolayer(forecasted_arimax_lower95_ts, series="95% Lower Bound", linetype="dashed") +
  autolayer(forecasted_arimax_lower80_ts, series="80% Lower Bound", linetype="dashed") +
  autolayer(forecasted_arimax_upper80_ts, series="80% Upper Bound", linetype="dashed") +
  autolayer(forecasted_arimax_upper95_ts, series="95% Upper Bound", linetype="dashed") +
  ggtitle("ARIMAX(1,1,1) Forecast (Transformed to Original Scale)") +
  ylab("Actual Price") +
  xlab("Time") +
  theme_minimal()
```

```{r}
forecast::accuracy(forecast_arimax$mean, testSet$log_price)
forecast::accuracy(forecast_arimax_ts, actual_arimax_ts)
```

80% lower and upper bound from forecasts create a tighter bounds for the forecasting the actual price as shown in graph. However, since our price data is non-stationary, and there is a sudden increase towards the end, the ARIMAX model, which relies on historical patterns, struggles to capture this trend, leading to poorer performance on the test set.


## 2.3 GARCH Model
### 2.3.1 GARCH Parameters (Without Xreg)
```{r}
# Fitting ARIMA-GARCH
p = 0:5
q = 0:5
m = 0:3
n = 0:3


## select ARMA order
aic.arma.garch1 <- matrix(0, length(p), length(q)) 
for (i in 1:length(p)) {
  for (j in 1:length(q)) {
      modij = arima(trainSet$diff_log_price, order = c(p[i], 0, q[j]), method = "ML")
      aic.arma.garch1[i, j] = AIC(modij)
  }
}

j.arma <- ceiling(which.min(aic.arma.garch1) / length(p))
i.arma <- which.min(aic.arma.garch1) - (j.arma-1)*length(p)
sprintf("Selected order for ARMA: %d, %d", p[i.arma], q[j.arma])


## select GARCH order
aic.arma.garch2 <- matrix(0, length(m), length(n)) 
for (i in 1:length(m)) {
  for (j in 1:length(n)) {
      spec = ugarchspec(variance.model=list(garchOrder=c(m[i],n[j])),
                mean.model=list(armaOrder=c(p[i.arma], q[j.arma]), include.mean=T),
                distribution.model="std")   
      modij = ugarchfit(spec=spec, data = trainSet$diff_log_price, solver = 'hybrid')
      aic.arma.garch2[i, j] = infocriteria(modij)[1]
  }
}
j.garch <- ceiling(which.min(aic.arma.garch2) / length(m))
i.garch <- which.min(aic.arma.garch2) - (j.garch-1)*length(m)
sprintf("Selected order for GARCH: %d, %d", m[i.garch], n[j.garch])



## select ARMA order again
aic.arma.garch3 <- matrix(0, length(p), length(q)) 
for (i in 1:length(p)) {
  for (j in 1:length(q)) {
      spec = ugarchspec(variance.model=list(garchOrder=c(m[i.garch],n[j.garch])),
                mean.model=list(armaOrder=c(p[i], q[j]), include.mean=T),
                distribution.model="std")   
      modij = ugarchfit(spec=spec, data = trainSet$diff_log_price, solver = 'hybrid')
      aic.arma.garch3[i, j] = infocriteria(modij)[1]
  }
}
j.arma <- ceiling(which.min(aic.arma.garch3) / length(p))
i.arma <- which.min(aic.arma.garch3) - (j.arma-1)*length(p)
sprintf("Selected order for ARMA: %d, %d", p[i.arma], q[j.arma])




# Select GARCH order again. 
aic.arma.garch4 <- matrix(0, length(m), length(n)) 
for (i in 1:length(m)) {
  for (j in 1:length(n)) {
      spec <- ugarchspec(
          variance.model = list(garchOrder = c(m[i], n[j])),
          mean.model = list(armaOrder = c(p[i.arma], q[j.arma]), include.mean = T),
          distribution.model = "std"
      )   

      modij <- tryCatch(
          ugarchfit(spec = spec, data = trainSet$diff_log_price, solver = 'hybrid'),
          error = function(e) return(NULL)  # Catch errors and return NULL
      )

      if (is.null(modij) || !inherits(modij, "uGARCHfit")) {
          print(paste("Model failed for m =", m[i], ", n =", n[j]))
          next
      } else {
          aic.arma.garch4[i, j] <- infocriteria(modij)[1]
      }
  }
}
j.garch <- ceiling(which.min(aic.arma.garch4) / length(m))
i.garch <- which.min(aic.arma.garch4) - (j.garch-1)*length(m)
sprintf("Selected order for GARCH: %d, %d", m[i.garch], n[j.garch])

## select ARMA order again
aic.arma.garch5 <- matrix(0, length(p), length(q)) 
for (i in 1:length(p)) {
  for (j in 1:length(q)) {
      spec = ugarchspec(variance.model=list(garchOrder=c(m[i.garch],n[j.garch])),
                mean.model=list(armaOrder=c(p[i], q[j]), include.mean=T),
                distribution.model="std")   
      modij = ugarchfit(spec=spec, data = trainSet$diff_log_price, solver = 'hybrid')
      aic.arma.garch5[i, j] = infocriteria(modij)[1]
  }
}
j.arma <- ceiling(which.min(aic.arma.garch5) / length(p))
i.arma <- which.min(aic.arma.garch5) - (j.arma-1)*length(p)
sprintf("Selected order for ARMA: %d, %d", p[i.arma], q[j.arma])

spec <- ugarchspec(variance.model=list(garchOrder=c(m[i.garch],n[j.garch])),
                mean.model=list(armaOrder=c(p[i.arma], q[j.arma]), include.mean=T),
                distribution.model="std")   
model.arma.garch <- ugarchfit(spec, data = trainSet$diff_log_price)
model.arma.garch@fit$coef
```

```{r}
model.arma.garch
```
```{r}
infocriteria(model.arma.garch)
```

```{r}
time_index <- as.POSIXct(trainSet$Time)  # Convert if needed
residuals_xts <- xts(residuals(model.arma.garch), order.by = time_index)
std_resid_xts <- xts(model.arma.garch@fit$z, order.by = time_index)

# Residual Analysis
par(mfrow = c(2, 2))

# Residual plots
plot(residuals_xts, main = "Residuals")
plot(std_resid_xts, main = "Standardized Residuals")

# ACF plots
acf(na.omit(as.numeric(residuals(model.arma.garch))), main = "ACF of Residuals")
acf(na.omit(as.numeric(residuals(model.arma.garch)^2)), main = "ACF of Squared Residuals")

# ACF of standardized residuals
acf(na.omit(model.arma.garch@fit$z), main = "ACF of Standardized Residuals")
acf(na.omit(model.arma.garch@fit$z^2), main = "ACF of Squared Standardized Residuals")

# Ljung-Box test for autocorrelation in residuals
Box.test(as.numeric(residuals(model.arma.garch)), lag = 20, type = "Ljung-Box")

# Ljung-Box test for autocorrelation in squared residuals
# Box.test(as.numeric(residuals(model.arma.garch))^2, lag = 20, type = "Ljung-Box")

# Shapiro-Wilk test for normality of residuals
shapiro.test(as.numeric(residuals(model.arma.garch)))
```

- shapiro-wilk test: p < 0.05 -> reject null hypothesis ->residuals are not normally distributed.

```{r}
# Q-Q plot for residuals
qqnorm(as.numeric(residuals(model.arma.garch)), main = "ARMA-GARCH: Q-Q Plot of Residuals")
qqline(as.numeric(residuals(model.arma.garch)), col = "red", lwd = 2)
```


### 2.3.2 GARCH Forecast with param selection (Without Xreg)
```{r}
# Define number of forecast steps (same as test set length)
nfore = length(testSet$diff_log_price)

# Initialize storage for forecasts
fore.series = NULL
fore.sigma = NULL

# Rolling forecast loop
for (f in 1:nfore) {
    # Expand training data dynamically
    data = trainSet$diff_log_price
    if (f > 1) {
        data = c(trainSet$diff_log_price, testSet$diff_log_price[1:(f - 1)])
    }
    
    # Fit GARCH model to updated training data
    model.garch.forecast = ugarchfit(spec, data, solver = "hybrid")
    
    # One-step-ahead forecast
    fore = ugarchforecast(model.garch.forecast, n.ahead = 1)
    
    # Store forecasted return and volatility
    fore.series = c(fore.series, fore@forecast$seriesFor)
    fore.sigma = c(fore.sigma, fore@forecast$sigmaFor)
}
```

```{r}
# Convert log returns back to price level
last_train_price <- tail(trainSet$month_Price, 1)
forecast.arma.garch.price <- last_train_price * exp(cumsum(fore.series))
```

```{r}
forecast.garch.df <- tibble(
  Time = testSet$Time,
  Price = forecast.arma.garch.price
)
test.garch.df <- tibble(
  Time = testSet$Time,
  Price = testSet$month_Price
)
```

```{r}
ggplot() +
  geom_line(data = test.garch.df, aes(x = Time, y = Price, color = "Actual")) +
  geom_line(data = forecast.garch.df, aes(x = Time, y = Price, color = "Forecast")) +
  labs(
    title = "sGARCH(3,1) with ARFIMA(4,0,4) Forecast vs Actual Prices (Monthly)", 
    y = "Price", 
    x = "Time",
    color = "Legend"
  ) +
  theme_minimal() +
  scale_color_manual(values = c("Actual" = "black", "Forecast" = "blue"))
```

```{r}
garch_predicted_vol <- sigma(garch_forecast)
actual_vol <- abs(testSet$log_price)  # Assuming you have log-returns
rmse_garch_test <- sqrt(mean((garch_predicted_vol - actual_vol)^2, na.rm = TRUE))
print(rmse_garch_test)
```

```{r}
garch_train_vol <- sigma(garch_fit)
actual_train_vol <- abs(trainSet$log_price)  # Assuming you have log-returns
rmse_garch <- sqrt(mean((garch_train_vol - actual_train_vol)^2, na.rm = TRUE))
print(rmse_garch)
```

```{r}
train_ts <- ts(trainSet$diff_log_price, start = start(min(trainSet$Time)), frequency = 12)
garch_fitted_ts <- ts(fitted(garch_fit), start = start(min(trainSet$Time)), frequency = 12)
plot(train_ts, type='l', col='black', main="Garch: Train Set Log Prices vs Fitted", 
     ylab="Log Price", xlab="Time")
lines(garch_fitted_ts, col='red')
```
### 2.3.3 GARCH Parameters (With Xreg)
```{r}
# Fitting ARIMA-GARCH
p = 0:5
q = 0:5
m = 0:3
n = 0:3


## select ARMA order
aic.armax.garch1 <- matrix(0, length(p), length(q)) 
for (i in 1:length(p)) {
  for (j in 1:length(q)) {
      modij = arima(trainSet$diff_log_price, order = c(p[i], 0, q[j]), method = "ML", xreg=xreg_matrix)
      aic.armax.garch1[i, j] = AIC(modij)
  }
}

j.armax <- ceiling(which.min(aic.armax.garch1) / length(p))
i.armax <- which.min(aic.armax.garch1) - (j.armax-1)*length(p)
sprintf("Selected order for ARMA: %d, %d", p[i.armax], q[j.armax])


## select GARCH order
aic.armax.garch2 <- matrix(0, length(m), length(n)) 
for (i in 1:length(m)) {
  for (j in 1:length(n)) {
      spec = ugarchspec(variance.model=list(garchOrder=c(m[i],n[j])),
                mean.model=list(armaOrder=c(p[i.armax], q[j.armax]), include.mean=T,
                                xreg=xreg_matrix),
                distribution.model="std")   
      modij = ugarchfit(spec=spec, data = trainSet$diff_log_price, solver = 'hybrid')
      aic.armax.garch2[i, j] = infocriteria(modij)[1]
  }
}
j.garch <- ceiling(which.min(aic.armax.garch2) / length(m))
i.garch <- which.min(aic.armax.garch2) - (j.garch-1)*length(m)
sprintf("Selected order for GARCH: %d, %d", m[i.garch], n[j.garch])



## select ARMA order again
aic.armax.garch3 <- matrix(0, length(p), length(q)) 
for (i in 1:length(p)) {
  for (j in 1:length(q)) {
      spec = ugarchspec(variance.model=list(garchOrder=c(m[i.garch],n[j.garch])),
                mean.model=list(armaOrder=c(p[i], q[j]), include.mean=T, xreg=xreg_matrix),
                distribution.model="std")   
      modij = ugarchfit(spec=spec, data = trainSet$diff_log_price, solver = 'hybrid')
      aic.armax.garch3[i, j] = infocriteria(modij)[1]
  }
}
j.armax <- ceiling(which.min(aic.armax.garch3) / length(p))
i.armax <- which.min(aic.armax.garch3) - (j.armax-1)*length(p)
sprintf("Selected order for ARMA: %d, %d", p[i.armax], q[j.armax])

# Select GARCH order again. 
aic.armax.garch4 <- matrix(0, length(m), length(n)) 
for (i in 1:length(m)) {
  for (j in 1:length(n)) {
      spec <- ugarchspec(
          variance.model = list(garchOrder = c(m[i], n[j])),
          mean.model = list(
            armaOrder = c(p[i.armax], q[j.armax]), 
            include.mean = T,
            xreg=xreg_matrix),
          distribution.model = "std"
      )   

      modij <- tryCatch(
          ugarchfit(spec = spec, data = trainSet$diff_log_price, solver = 'hybrid'),
          error = function(e) return(NULL)  # Catch errors and return NULL
      )

      if (is.null(modij) || !inherits(modij, "uGARCHfit")) {
          print(paste("Model failed for m =", m[i], ", n =", n[j]))
          next
      } else {
          aic.armax.garch4[i, j] <- infocriteria(modij)[1]
      }
  }
}
j.garch <- ceiling(which.min(aic.arma.garch4) / length(m))
i.garch <- which.min(aic.arma.garch4) - (j.garch-1)*length(m)
sprintf("Selected order for GARCH: %d, %d", m[i.garch], n[j.garch])

## select ARMA order again
aic.armax.garch5 <- matrix(0, length(p), length(q)) 
for (i in 1:length(p)) {
  for (j in 1:length(q)) {
      spec = ugarchspec(variance.model=list(garchOrder=c(m[i.garch],n[j.garch])),
                mean.model=list(armaOrder=c(p[i], q[j]), include.mean=T,
                                xreg=xreg_matrix),
                distribution.model="std")   
      modij = ugarchfit(spec=spec, data = trainSet$diff_log_price, solver = 'hybrid')
      aic.armax.garch5[i, j] = infocriteria(modij)[1]
  }
}
j.armax <- ceiling(which.min(aic.armax.garch5) / length(p))
i.armax <- which.min(aic.armax.garch5) - (j.armax-1)*length(p)
sprintf("Selected order for ARMA: %d, %d", p[i.armax], q[j.armax])

spec <- ugarchspec(variance.model=list(garchOrder=c(m[i.garch],n[j.garch])),
                mean.model=list(armaOrder=c(p[i.armax], q[j.armax]), include.mean=T,
                                xreg=xreg_matrix),
                distribution.model="std")   
model.armax.garch <- ugarchfit(spec, data = trainSet$diff_log_price)
model.armax.garch@fit$coef
```

```{r}
model.armax.garch
```

```{r}
infocriteria(model.armax.garch)
```

```{r}
garch_time_index <- as.POSIXct(trainSet$Time)  # Convert if needed
residuals_armax_garch_xts <- xts(residuals(model.armax.garch), order.by = time_index)
std_resid_armax_garch_xts <- xts(model.armax.garch@fit$z, order.by = time_index)

# Residual Analysis
par(mfrow = c(2, 2))

# Residual plots
plot(residuals_armax_garch_xts, main = "Residuals")
plot(std_resid_armax_garch_xts, main = "Standardized Residuals")

# ACF plots
acf(na.omit(as.numeric(residuals(model.armax.garch))), main = "ACF of Residuals")
acf(na.omit(as.numeric(residuals(model.armax.garch)^2)), main = "ACF of Squared Residuals")

# ACF of standardized residuals
acf(na.omit(model.armax.garch@fit$z), main = "ACF of Standardized Residuals")
acf(na.omit(model.armax.garch@fit$z^2), main = "ACF of Squared Standardized Residuals")
```

```{r}
checkresiduals(model.armax.garch)
```


```{r}
# Extract the actual data (assuming you are using `trainSet` or the original series)
arma.garch.actual.values <- trainSet$diff_log_price

# Extract fitted values from the GARCH model (use `fitted` for the model residuals)
arma.garch.fitted.values <- fitted(model.armax.garch)

arma.garch.fit.df <- tibble(
  Time = trainSet$Time,
  Price = arma.garch.fitted.values
)
arma.garch.train.df <- tibble(
  Time = trainSet$Time,
  Price = trainSet$diff_log_price
)
```

```{r}
ggplot() +
  geom_line(data = arma.garch.fit.df, aes(x = Time, y = Price, color = "Fitted")) +
  geom_line(data = arma.garch.train.df, aes(x = Time, y = Price, color = "Actual")) +
  labs(
    title = "sGARCH(3,1) with ARFIMA(4,0,4) Model: Fitted vs Actual Prices", 
    y = "Price", 
    x = "Time",
    color = "Legend"
  ) +
  theme_minimal() +
  scale_color_manual(values = c("Actual" = "black", "Fitted" = "red"))
```

### 2.3.4 GARCH Forecast with param selection (With Xreg)
```{r}
# Define number of forecast steps (same as test set length)
ngarchfore = length(testSet$diff_log_price)

spec <- ugarchspec(variance.model=list(garchOrder=c(3,1)),
                mean.model=list(armaOrder=c(4, 4), include.mean=T,
                                xreg=xreg_matrix),
                distribution.model="std")   

# Initialize storage for forecasts
fore.garch.x.series = NULL
fore.garch.x.sigma = NULL

# Rolling forecast loop
for (f in 1:ngarchfore) {
    # Expand training data dynamically
    data = trainSet$diff_log_price
    if (f > 1) {
        data = c(trainSet$diff_log_price, testSet$diff_log_price[1:(f - 1)])
    }
    
    # Fit GARCH model to updated training data
    model.garch.x.forecast = ugarchfit(spec, data, solver = "hybrid")
    
    # One-step-ahead forecast
    fore = ugarchforecast(model.garch.x.forecast, n.ahead = 1)
    
    # Store forecasted return and volatility
    fore.garch.x.series = c(fore.garch.x.series, fore@forecast$seriesFor)
    fore.garch.x.sigma = c(fore.garch.x.sigma, fore@forecast$sigmaFor)
}
```

```{r}
# Convert log returns back to price level
last_train_price <- tail(trainSet$month_Price, 1)
forecast.armax.garch.price <- last_train_price * exp(cumsum(fore.garch.x.series))
```

```{r}
forecast.garch.df <- tibble(
  Time = testSet$Time,
  Price = forecast.arma.garch.price
)
test.garch.df <- tibble(
  Time = testSet$Time,
  Price = testSet$month_Price
)
```

```{r}
ggplot() +
  geom_line(data = test.garch.df, aes(x = Time, y = Price, color = "Actual")) +
  geom_line(data = forecast.garch.df, aes(x = Time, y = Price, color = "Forecast")) +
  labs(
    title = "sGARCH(3,1) with ARFIMA(4,0,4) Forecast vs Actual Prices (Monthly)", 
    y = "Price", 
    x = "Time",
    color = "Legend"
  ) +
  theme_minimal() +
  scale_color_manual(values = c("Actual" = "black", "Forecast" = "blue"))
```

```{r}
garch_predicted_vol <- sigma(garch_forecast)
actual_vol <- abs(testSet$log_price)  # Assuming you have log-returns
rmse_garch_test <- sqrt(mean((garch_predicted_vol - actual_vol)^2, na.rm = TRUE))
print(rmse_garch_test)
```

```{r}
garch_train_vol <- sigma(garch_fit)
actual_train_vol <- abs(trainSet$log_price)  # Assuming you have log-returns
rmse_garch <- sqrt(mean((garch_train_vol - actual_train_vol)^2, na.rm = TRUE))
print(rmse_garch)
```



## 2.5 GAM Model
### 2.5.1 Fit Model
#### 2.5.1.1 Basic Model
```{r}
# Uses simple smoothing splines for variables
trainSet$monthFac <- as.factor(format(trainSet$Time, "%m"))
trainSet$month_num <- as.numeric(trainSet$monthFac)

gam_basic <- gam(diff_log_price ~ s(month_num, bs="cc", k=12) + s(Avg_Temp) + s(exchange_rate), 
                 data = trainSet, method = "REML")
```

```{r}
gam.check(gam_basic)
```
```{r}
summary(gam_basic)
```

#### 2.5.1.2 Complex Model
```{r}
trainSet$dateInt = as.integer(trainSet$Time)
trainSet$Time_num <- as.numeric(trainSet$Time) / 365  # Convert to years
gam_year <- gam(diff_log_price ~ s(month_num, bs="cc", k=12) + 
                  sinpi(dateInt / 182.625) + cospi(dateInt / 182.625) + 
                  sinpi(dateInt / 91.3125) + cospi(dateInt / 91.3125) + 
                  s(Avg_Temp) +  s(exchange_rate), data = trainSet, method = "REML")
```

```{r}
summary(gam_basic)
summary(gam_year)
```

```{r}
# plot(gam_complex, pages = 1, shade = TRUE)
```

```{r}
# gam.check(gam_complex) 
```

### 2.5.2 Forecast and Plot
```{r}
testSet$month_num <- as.numeric(format(testSet$Time, "%m"))
testSet$Time_num <- as.numeric(difftime(testSet$Time, min(trainSet$Time), units="days")) / 365
testSet$dateInt = as.integer(testSet$Time)

testSet$pred_log <- predict(gam_year, newdata = testSet)
testSet$pred_log_price <- last_log_price + cumsum(testSet$pred_log)
testSet$pred_price <- exp(testSet$pred_log_price)

# testSet$pred_price <- exp(log(last_price) + cumsum(testSet$pred_log))
# testSet$pred_price <- exp(cumsum(testSet$pred_log) + last_log_price)
```

```{r}
ggplot(testSet, aes(x = Time)) +
  geom_line(aes(y = month_Price, color = "Actual")) +
  geom_line(aes(y = pred_price, color = "Predicted")) +
  labs(title = "Actual vs. Predicted Price", 
       x = "Time", y = "Price") +
  scale_color_manual(values = c("Actual" = "black", "Predicted" = "red")) +
  theme_minimal()
```
```{r}
rmse(testSet$month_Price, testSet$pred_price)
```


## 2.6 XGBoost Model
```{r}
trainSet$Lag1 <- lag(trainSet$diff_log_price, 1)
trainSet$Lag12 <- lag(trainSet$diff_log_price, 12)
testSet$Lag1 <- lag(testSet$diff_log_price, 1)
testSet$Lag12 <- lag(testSet$diff_log_price, 12)

predictors <- c("Time", "Avg_Temp", "exchange_rate", "Lag1", "Lag12")
target <- "diff_log_price"
```

```{r}
train_data <- trainSet[complete.cases(trainSet[, c(predictors, target)]), ]
test_data <- testSet[complete.cases(testSet[, predictors]), ]

train_data <- train_data |>
  mutate(across(all_of(predictors), as.numeric)) 
test_data <- test_data |>
  mutate(across(all_of(predictors), as.numeric))

# Convert to DMatrix (XGBoost's optimized format)
dtrain <- xgb.DMatrix(
  data = as.matrix(train_data[, predictors]),
  label = train_data[[target]]
)
```

```{r}
params <- list(
  objective = "reg:squarederror",  # For regression
  eta = 0.05,                      # Learning rate (lower for time series)
  max_depth = 6,                   # Tree depth (avoid overfitting)
  subsample = 0.8,                 # Random subset of data per tree
  colsample_bytree = 0.8,          # Random subset of features per tree
  gamma = 1,                       # Minimum loss reduction for splits
  min_child_weight = 5             # Prevent overfitting to small groups
)

set.seed(123)
xgb_model <- xgb.train(
  params,
  data = dtrain,
  nrounds = 1000,                  # Large number (early stopping will handle)
  watchlist = list(train = dtrain),
  early_stopping_rounds = 50,      # Stop if no improvement for 50 rounds
  print_every_n = 10
)
```

```{r}
dtest <- xgb.DMatrix(as.matrix(test_data[, predictors]))
test_data$pred_diff_log <- predict(xgb_model, dtest)

# Convert to actual price predictions
test_data <- test_data %>%
  mutate(
    pred_log_price = last_log_price + cumsum(pred_diff_log),  # Only if modeling differences
    pred_price = exp(pred_log_price)
  )
```

```{r}
ggplot(test_data, aes(x = Time)) +
  geom_line(aes(y = month_Price, color = "Actual")) +
  geom_line(aes(y = pred_price, color = "Predicted")) +
  labs(title = "XGBoost: Actual vs. Predicted Price",
       x = "Time", y = "Price") +
  scale_color_manual(values = c("Actual" = "black", "Predicted" = "red")) +
  theme_minimal()
```


```{r}
# xgb = XGBClassifier(random_state=42)
# xgb.fit(predictors, target)
```









