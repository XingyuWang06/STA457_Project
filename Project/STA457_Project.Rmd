---
title: "STA457 Project"
author: "Xing Yu Wang"
date: "2025-03-29"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", out.width = "75%")
```

```{r, message=FALSE}
library(dplyr)
library(tidyverse)
library(readr)
library(lubridate)
library(forecast)
library(astsa)
library(tseries)
library(mgcv)
library(Metrics)
library(ggplot2)
library(xgboost)
# library(XGBClassifier)
library(rugarch)
library(tibble)
library(xts)
```

# 1. EDA
```{r}
price = read.csv("./Daily Prices_ICCO.csv")
weather = read.csv("./Ghana_data.csv")
USD_GHS_Historical_Data = read.csv("./USD_GHS Historical Data.csv")
```

## 1.1 Clean Data
```{r}
weather <- weather |> dplyr::select(DATE, TAVG)
exchangerate <- USD_GHS_Historical_Data |> dplyr::select(Date, Price)
```

```{r}
colnames(price)[colnames(price) == 'ICCO.daily.price..US..tonne.'] <- 'Daily_Price'
colnames(weather)[colnames(weather) == 'DATE'] <- 'Date'
colnames(weather)[colnames(weather) == 'TAVG'] <- 'Avg_Temp'
colnames(exchangerate)[colnames(exchangerate) == 'Price'] <- 'exchange_rate'
```

## 1.2 Check duplicated values
```{r}
price |> group_by(Date) |> filter(n() > 1) |> ungroup()
```

```{r}
price <- price |> filter(!(Date == "31/01/2024" & Daily_Price == "10,888.05"))
price <- price |> filter(!(Date == "30/01/2024" & Daily_Price == "10,676.42"))
price <- distinct(price)
```

## 1.3 Convert to Time Series Data
### 1.3.1 price Dataset
```{r}
price$Date <- as.Date(price$Date, format="%d/%m/%Y")
price$Daily_Price <- as.numeric(gsub(",", "", price$Daily_Price))
price_month <- price |> mutate(Time = floor_date(Date, "month")) |> group_by(Time) |> 
  summarise(month_Price = mean(Daily_Price, na.rm = TRUE)) |> ungroup()
```

```{r}
summary(price)
```

```{r}
price_ts <- ts(price_month$month_Price, start = c(1994, 11), end = c(2024, 11), frequency = 12)
```

```{r}
plot(price_ts, main="Monthly Price Time Series", ylab="Price", xlab="Time")
```

```{r}
acf2(price_ts, 50)
```

```{r}
ndiffs(price_ts)
```

```{r}
price_month$price_log <- log(price_month$month_Price)
adf.test(price_month$price_log)
```

```{r}
acf2(price_month$price_log, 50)
```

Hence, we want to difference the price data.

```{r}
diff_log_price = diff(price_month$price_log)
ts.plot(diff_log_price, main = "Log Differenced Price Data", ylab = "Log Differenced Price")
```

```{r}
adf.test(diff_log_price)
```

```{r}
acf2(diff_log_price, 50)
```

### 1.3.2 ghana Dataset
```{r}
weather$Date <- as.Date(weather$Date)
weather$Avg_Temp <- as.numeric(gsub("", "", weather$Avg_Temp))
weather_month <- weather |> mutate(Time = floor_date(Date, "month")) |> group_by(Time) |> 
  summarise(Avg_Temp = mean(Avg_Temp, na.rm = TRUE)) |> ungroup()
```

```{r}
summary(weather_month)
```

```{r}
weather_ts <- ts(weather_month$Avg_Temp, start = c(1994, 11), end = c(2024, 11), frequency = 12)
```

```{r}
ts.plot(weather_ts, main="Monthly Average Temperature Time Series", ylab="Temperature", xlab="Time")
```

### 1.3.3 exchange Data
```{r}
exchangerate$Date <- as.Date(exchangerate$Date)
exchangerate$exchange_rate <- as.numeric(gsub("", "", exchangerate$exchange_rate))
rate_month <- exchangerate |> mutate(Time = floor_date(Date, "month")) |> group_by(Time) |> 
  summarise(exchange_rate = mean(exchange_rate, na.rm = TRUE)) |> ungroup()
```

```{r}
summary(exchangerate)
```

```{r}
rate_ts <- ts(rate_month$exchange_rate, start = c(1994, 11), end = c(2024, 11), frequency = 12)
```

```{r}
ts.plot(rate_ts, main="Monthly Average Exchange Rate Time Series", ylab="Exchange Rate (USD/GHS)", xlab="Time")
```

```{r}
par(mfrow=c(3,1), mar = c(3, 4, 2, 2))
# price
plot(price_ts, main="Monthly Price Time Series", ylab="Price", xlab="Time")
#temperature
ts.plot(weather_ts, main="Monthly Average Temperature Time Series", ylab="Temperature", xlab="Time")
# exchange rate
ts.plot(rate_ts, main="Monthly Average Exchange Rate Time Series", ylab="Exchange Rate (USD/GHS)", xlab="Time")
```

## 1.4 Time series plots for data
```{r}
ggtsdisplay(price_ts, main="Time series plot for Monthly World Cocoa Price")
```

```{r}
ggtsdisplay(weather_ts, main="Time series plot for Monthly Average Temperature")
```

```{r}
ggtsdisplay(rate_ts, main="Time series plot for Monthly Average Exchange Rate(USD/GHS)")
```

```{r}
par(mfrow=c(3,1), mar = c(3, 4, 2, 2))
# price
plot(price_ts, main="Monthly Price Time Series", ylab="Price", xlab="Time")
#temperature
ts.plot(weather_ts, main="Monthly Average Temperature Time Series", ylab="Temperature", xlab="Time")
# exchange rate
ts.plot(rate_ts, main="Monthly Average Exchange Rate Time Series", ylab="Exchange Rate (USD/GHS)", xlab="Time")
```


## 1.5 Combine Datasets
```{r}
data <- price_month |> left_join(weather_month, by = "Time") |> left_join(rate_month, by = "Time")
data <- data |> mutate(log_price = log(month_Price), diff_log_price = 
                         c(NA, diff(price_month$price_log))) |> drop_na()
data <- data |> dplyr::select(Time, Avg_Temp, exchange_rate, diff_log_price, log_price, month_Price)

data$Time <- as.Date(data$Time)
```

```{r}
plot(data$Avg_Temp, data$month_Price, xlab = "Monthly Price", ylab = "Average Temperature", 
     main = "Daily Price vs. Avg Temperature")
pairs(data[, c("month_Price", "Avg_Temp", "exchange_rate")])
```


## 1.6 Stationary Check
```{r}
adf.test(data$Avg_Temp)
adf.test(data$exchange_rate)
adf.test(log(data$exchange_rate))
adf.test(diff(log(data$exchange_rate)))
```

Since monthly average temperature is already stationary, we would do take the differenced and log-transformed exchange rate as our exogenous factors.

```{r}
acf2(data$exchange_rate)
acf2(log(data$exchange_rate))
acf2(diff(log(data$exchange_rate)))
```

ACF shows similar trend, where only differenced log-transformed exchange rate is stationary. Hence, this differenced and log-transformed exchange rate will be used as one of the external(exogenous) regressors in ARIMAX and GARCHX.

```{r}
adf.test(data$month_Price)
adf.test(data$log_price)
adf.test(data$diff_log_price)
```

Since only the diff_log_price is stationary, we choose differenced monthly log price when fitting the model.

```{r}
diff_price_ts <- ts(data$diff_log_price, frequency = 12)
autoplot(decompose(diff_price_ts, type="additive")) +
  ggtitle("Decomposition of Differenced Log Price Time Series") +
  theme_minimal()
```


## 1.7 Split data
```{r}
data <- data[order(data$Time), ]
cutoff <- floor(0.7 * nrow(data))
trainSet <- data[1:cutoff, ]
testSet <- data[(cutoff+1):nrow(data), ]
```

# 2. Method
## 2.1 ETS Model
ETS is a purely univariate model and cannot directly handle external regressors.
```{r}
data_train_ts <- ts(trainSet$diff_log_price, frequency = 12)
```

### 2.1.1 Fit Model
```{r}
ets_model <- ets(data_train_ts, model = "ANA")
ets_zmodel <- ets(data_train_ts, model = "ZZZ") # Automatically selects best model
summary(ets_model)
summary(ets_zmodel)
```

```{r}
plot(ets_model)
```

### 2.1.2 Forecasting and Plotting
```{r}
# Plot using log differenced price
data_test_ts <- ts(testSet$diff_log_price, start = end(data_train_ts) + c(0,1), 
                   frequency = 12)

h <- nrow(testSet)
forecast_ets <- forecast(ets_model, h = h)

autoplot(forecast_ets) + autolayer(data_test_ts, series = "Actual", color = "red")
```
The red line is the observed actual values. The forecasted values are the central blue line within the blue shaded prediction intervals.

```{r}
last_log_price <- tail(trainSet$log_price, 1)

# Convert back to actual price
forecasted_price <- exp(cumsum(forecast_ets$mean) + last_log_price)

actual_price <- exp(testSet$log_price)
```

```{r}
data_test_ts <- ts(testSet$diff_log_price, start = end(data_train_ts) + c(0,1), 
                   frequency = 12)

forecast_ets_ts <- ts(forecasted_price, start = start(data_test_ts), frequency = 12)
actual_ets_ts <- ts(actual_price, start = start(data_test_ts), frequency = 12)
```

```{r}
# Plot using actual price
autoplot(forecast_ets_ts, series = "Predicted") + 
  autolayer(actual_ets_ts, series = "Actual", color = "blue") +
  ggtitle("Forecast vs Actual Prices") +
  ylab("Price") +
  xlab("Time") +
  theme_minimal()
```
```{r}
checkresiduals(ets_model)
checkresiduals(ets_zmodel)
```

## 2.2 ARIMAX Model

Recall that in Section 1.3.1, we have tested the acf and adf.test, and determined that we would be using the differenced price data. To fit the trainset, we evaluate p and q for ARIMA model.

```{r}
adf.test(trainSet$log_price)
```

Next, we check if applying 1st differencing is good enough
```{r}
adf.test(diff(trainSet$month_Price))
```
P-value is smaller than 0.01 for differenced log price, and we are

```{r}
acf2(trainSet$diff_log_price)
```

```{r}
adf.test(data$Avg_Temp)
```


```{r}
adf.test(diff(log(data$exchange_rate)))
```


### 2.2.1 Fit ARIMAX Model


```{r}
dl.rate.train <- c(0, diff(log(trainSet$exchange_rate)))
xreg_matrix <- cbind(trainSet$Avg_Temp, dl.rate.train)
colnames(xreg_matrix) <- c("Avg_Temp", "dl_exchange_rate")

p <- 0:10
q <- 0:10
aic.arimax <- matrix(0, length(p), length(q)) 
for (i in 1:length(p)) {
  for (j in 1:length(q)) {
      modij = Arima(trainSet$diff_log_price, order = c(p[i], 0, q[j]), 
                    method = "ML", xreg=xreg_matrix)
      aic.arimax[i, j] = AIC(modij)
  }
}

j.arimax <- ceiling(which.min(aic.arimax) / length(p))
i.arimax <- which.min(aic.arimax) - (j.arimax-1)*length(p)
sprintf("Selected order for ARIMAX: p = %d, q = %d", p[i.arimax], q[j.arimax])
```

```{r}
model.arimax <- Arima(trainSet$diff_log_price, order=c(2,0,3), xreg = xreg_matrix)
summary(model.arimax)
```

```{r}
checkresiduals(model.arimax)
```

```{r}
qqnorm(model.arimax$residuals)
qqline(model.arimax$residuals, col="red")
```
```{r}
adf.test(model.arimax$residuals)
```

- ADF Test on ARIMAX Model Residuals: Failed to reject H_0, indicating that the residuals do not exhibit significant autocorrelation.
- Histogram and QQ-Plot of Residuals: Residuals align well with the 45-degree line, suggesting normality.
- ACF of Residuals: Appears random, with all lags within the range of -0.15 to 0.1, indicating no strong autocorrelations.
- Standardized Residuals Plot: No discernible trend observed, further supporting the model’s adequacy.
- Ljung-Box Test (Residuals from ARIMA(2,0,3) model):
  - Q^* = 7.1814, df = 5, p-value = 0.2075
  - Model degrees of freedom: 5, Total lags used: 10
Conclusion: The ARIMAX model effectively captures the trend of the training dataset.

### 2.2.2 Forecasting With ARIMAX Model
Next we try to fit this ARIMAX model to forecast on testing set.

```{r}
dl.rate.test <- c(0, diff(log(testSet$exchange_rate)))
forecast.arimax.xreg <- cbind(testSet$Avg_Temp, dl.rate.test)
colnames(forecast.arimax.xreg) <- c("Avg_Temp", "dl_exchange_rate")
forecast.arimax <- forecast(model.arimax, xreg=forecast.arimax.xreg, 
                            h=nrow(testSet))

last_log_price <- tail(trainSet$log_price, 1)
# Convert back to actual price
forecast.arimax.final <- exp(cumsum(forecast.arimax$mean) + last_log_price)
```

```{r}
model.arimax.fitted <- as.numeric(model.arimax$fitted)
model.arimax.fitted.converted <- exp(log(trainSet$month_Price[1]) 
                                     + cumsum(model.arimax.fitted))
rmse(trainSet$month_Price, model.arimax.fitted.converted)
mae(trainSet$month_Price, model.arimax.fitted.converted)
mape(trainSet$month_Price, model.arimax.fitted.converted)
```

```{r}
rmse(testSet$month_Price, forecast.arimax.final)
mae(testSet$month_Price, forecast.arimax.final)
mape(testSet$month_Price, forecast.arimax.final)
```

```{r}
forecast.arimax.df <- tibble(
  Time = testSet$Time,
  Price = forecast.arimax.final
)
test.arimax.df <- tibble(
  Time = testSet$Time,
  Price = testSet$month_Price
)
```

```{r}
ggplot() +
  geom_line(data = test.arimax.df, aes(x = Time, y = Price, color = "Actual")) +
  geom_line(data = forecast.arimax.df, aes(x = Time, y = Price, color = "Forecast")) +
  labs(
    title = "ARIMAX(2,0,3) Forecast vs Actual Monthly Prices", 
    y = "Price", 
    x = "Time",
    color = "Legend"
  ) +
  theme_minimal() +
  scale_color_manual(values = c(
    "Actual" = "black",
    "Forecast" = "red"))
```
## 2.3 GARCH Model
### 2.3.1 GARCH Parameters (With Xreg)

```{r}
# xreg_matrix is the same as arimax
p = 0:3
q = 0:3
## select ARMA order
aic.armax.garch1 <- matrix(0, length(p), length(q)) 
for (i in 1:length(p)) {
  for (j in 1:length(q)) {
      modij = Arima(trainSet$diff_log_price, order = c(p[i], 0, q[j]), 
                    method = "ML", xreg=xreg_matrix)
      aic.armax.garch1[i, j] = AIC(modij)
  }
}

j.armax <- ceiling(which.min(aic.armax.garch1) / length(p))
i.armax <- which.min(aic.armax.garch1) - (j.armax-1)*length(p)
sprintf("Selected order for ARMA: %d, %d", p[i.armax], q[j.armax])
```

This is the same as what we have for ARIMAX

```{r}
m = 1:3
n = 1:3
# dl.rate.train <- c(0, diff(log(trainSet$exchange_rate)))
# xreg_matrix <- cbind(trainSet$Avg_Temp, dl.rate.train)
# colnames(xreg_matrix) <- c("Avg_Temp", "dl_exchange_rate")
## select GARCH order
aic.armax.garch2 <- matrix(0, length(m), length(n)) 
for (i in 1:length(m)) {
  for (j in 1:length(n)) {
      spec = ugarchspec(variance.model=list(model="sGARCH", 
                                            garchOrder=c(m[i],n[j])),
                mean.model=list(armaOrder=c(2, 3), 
                                include.mean=T, 
                                external.regressors = xreg_matrix),
                distribution.model="std")   
      modij = ugarchfit(spec=spec, data = trainSet$diff_log_price, 
                        solver = 'hybrid', trace = FALSE)
      aic.armax.garch2[i, j] = infocriteria(modij)[1]
  }
}
j.garch <- ceiling(which.min(aic.armax.garch2) / length(m))
i.garch <- which.min(aic.armax.garch2) - (j.garch-1)*length(m)
sprintf("Selected order for GARCH: %d, %d", m[i.garch], n[j.garch])
```

```{r}
spec <- ugarchspec(variance.model=list(garchOrder=c(1,1)),
                mean.model=list(armaOrder=c(2, 3), 
                                include.mean=T, 
                                external.regressors = xreg_matrix),
                distribution.model="std")   
model.armax.garch <- ugarchfit(spec, data = trainSet$diff_log_price,
                               solver = 'hybrid', trace = FALSE)
model.armax.garch
```

```{r}
model.armax.garch
```

```{r}
model.armax.garch@fit$coef
```

```{r}
garch_time_index <- as.POSIXct(trainSet$Time)
residuals_armax_garch_xts <- xts(residuals(model.armax.garch), 
                                 order.by = garch_time_index)
std_resid_armax_garch_xts <- xts(model.armax.garch@fit$z, 
                                 order.by = garch_time_index)

# Residual Analysis
par(mfrow = c(2, 2))

# Residual plots
plot(residuals_armax_garch_xts, main = "Residuals")
plot(std_resid_armax_garch_xts, main = "Standardized Residuals")

# ACF plots
acf(na.omit(as.numeric(residuals(model.armax.garch))), main = "ACF of Residuals")
acf(na.omit(as.numeric(residuals(model.armax.garch)^2)), main = "ACF of Squared Residuals")
```

```{r}
# Extract the actual data (assuming you are using `trainSet` or the original series)
armax.garch.actual.values <- trainSet$diff_log_price

# Extract fitted values from the GARCH model (use `fitted` for the model residuals)
armax.garch.fitted.values <- fitted(model.armax.garch)

armax.garch.fit.df <- tibble(
  Time = trainSet$Time,
  Price = armax.garch.fitted.values
)
armax.garch.train.df <- tibble(
  Time = trainSet$Time,
  Price = trainSet$diff_log_price
)
```

```{r}
ggplot() +
  geom_line(data = armax.garch.fit.df, aes(x = Time, y = Price, color = "Fitted")) +
  geom_line(data = armax.garch.train.df, aes(x = Time, y = Price, color = "Actual")) +
  labs(
    title = "sGARCH(1,1) with ARFIMA(2,0,3) Model: Fitted vs Actual Prices", 
    y = "Price", 
    x = "Time",
    color = "Legend"
  ) +
  theme_minimal() +
  scale_color_manual(values = c("Actual" = "grey", "Fitted" = "red"))
```

### 2.3.2 GARCH Forecast with param selection (With Xreg)
```{r}
# multi-step forecast
ngarchfore = length(testSet$diff_log_price)
xreg_test_matrix <- cbind(testSet$Avg_Temp, diff(log(testSet$exchange_rate)))
colnames(xreg_test_matrix) <- c("Avg_Temp", "dl_exchange_rate")

fore.garch.dl = ugarchforecast(model.armax.garch, n.ahead = ngarchfore,
                              external.forecasts = list(mreg=xreg_test_matrix))
fore.garch.dl.data <- fore.garch.dl@forecast$seriesFor
last_log_price <- tail(trainSet$log_price, 1)
forecast.armax.garch.multi <- exp(cumsum(fore.garch.dl.data) + last_log_price)

```

```{r}
forecast.garch.multi.df <- tibble(
  Time = testSet$Time,
  Price = forecast.armax.garch.multi
)
test.garch.df <- tibble(
  Time = testSet$Time,
  Price = testSet$month_Price
)
```

```{r}
ggplot() +
  geom_line(data = test.garch.df, aes(x = Time, y = Price, color = "Actual")) +
  geom_line(data = forecast.garch.multi.df, aes(x = Time, y = Price, color = "Forecast")) +
  labs(
    title = "sGARCH(1,1) with ARFIMA(2,0,3) Multi-steps Forecast vs Actual Monthly Prices", 
    y = "Price", 
    x = "Time",
    color = "Legend"
  ) +
  theme_minimal() +
  scale_color_manual(values = c("Actual" = "black", "Forecast" = "red"))
```

RMSE below shows the forecast ability of the final model with one-step forecast

```{r}
model.armax.garch.fitted <- as.numeric(fitted(model.armax.garch))
model.armax.garch.fitted.converted <- exp(log(trainSet$month_Price[1]) 
                                     + cumsum(model.armax.garch.fitted))
rmse(trainSet$month_Price, model.armax.garch.fitted.converted)
mae(trainSet$month_Price, model.armax.garch.fitted.converted)
mape(trainSet$month_Price, model.armax.garch.fitted.converted)
```

```{r}
rmse(testSet$month_Price, forecast.armax.garch.multi[1:length(testSet$Time)])
mae(testSet$month_Price, forecast.armax.garch.multi[1:length(testSet$Time)])
mape(testSet$month_Price, forecast.armax.garch.multi[1:length(testSet$Time)])
```



## 2.5 GAM Model
### 2.5.1 Fit Model
#### 2.5.1.1 Basic Model
```{r}
# Uses simple smoothing splines for variables
trainSet$monthFac <- as.factor(format(trainSet$Time, "%m"))
trainSet$month_num <- as.numeric(trainSet$monthFac)

gam_basic <- gam(diff_log_price ~ s(month_num, bs="cc", k=12) + s(Avg_Temp) + s(exchange_rate), 
                 data = trainSet, method = "REML")
```

```{r}
gam.check(gam_basic)
```
```{r}
summary(gam_basic)
```

#### 2.5.1.2 Complex Model
```{r}
trainSet$dateInt = as.integer(trainSet$Time)
trainSet$Time_num <- as.numeric(trainSet$Time) / 365  # Convert to years
gam_year <- gam(diff_log_price ~ s(month_num, bs="cc", k=12) + 
                  sinpi(dateInt / 182.625) + cospi(dateInt / 182.625) + 
                  sinpi(dateInt / 91.3125) + cospi(dateInt / 91.3125) + 
                  s(Avg_Temp) +  s(exchange_rate), data = trainSet, method = "REML")
```

```{r}
summary(gam_basic)
summary(gam_year)
```

```{r}
# plot(gam_complex, pages = 1, shade = TRUE)
```

```{r}
# gam.check(gam_complex) 
```

### 2.5.2 Forecast and Plot
```{r}
testSet$month_num <- as.numeric(format(testSet$Time, "%m"))
testSet$Time_num <- as.numeric(difftime(testSet$Time, min(trainSet$Time), units="days")) / 365
testSet$dateInt = as.integer(testSet$Time)

testSet$pred_log <- predict(gam_year, newdata = testSet)
testSet$pred_log_price <- last_log_price + cumsum(testSet$pred_log)
testSet$pred_price <- exp(testSet$pred_log_price)

# testSet$pred_price <- exp(log(last_price) + cumsum(testSet$pred_log))
# testSet$pred_price <- exp(cumsum(testSet$pred_log) + last_log_price)
```

```{r}
ggplot(testSet, aes(x = Time)) +
  geom_line(aes(y = month_Price, color = "Actual")) +
  geom_line(aes(y = pred_price, color = "Predicted")) +
  labs(title = "Actual vs. Predicted Price", 
       x = "Time", y = "Price") +
  scale_color_manual(values = c("Actual" = "black", "Predicted" = "red")) +
  theme_minimal()
```
```{r}
rmse(testSet$month_Price, testSet$pred_price)
```


## 2.6 XGBoost Model
```{r}
trainSet$Lag1 <- lag(trainSet$diff_log_price, 1)
trainSet$Lag12 <- lag(trainSet$diff_log_price, 12)
testSet$Lag1 <- lag(testSet$diff_log_price, 1)
testSet$Lag12 <- lag(testSet$diff_log_price, 12)

predictors <- c("Time", "Avg_Temp", "exchange_rate", "Lag1", "Lag12")
target <- "diff_log_price"
```

```{r}
train_data <- trainSet[complete.cases(trainSet[, c(predictors, target)]), ]
test_data <- testSet[complete.cases(testSet[, predictors]), ]

train_data <- train_data |>
  mutate(across(all_of(predictors), as.numeric)) 
test_data <- test_data |>
  mutate(across(all_of(predictors), as.numeric))

# Convert to DMatrix (XGBoost's optimized format)
dtrain <- xgb.DMatrix(
  data = as.matrix(train_data[, predictors]),
  label = train_data[[target]]
)
```

```{r}
params <- list(
  objective = "reg:squarederror",  # For regression
  eta = 0.05,                      # Learning rate (lower for time series)
  max_depth = 6,                   # Tree depth (avoid overfitting)
  subsample = 0.8,                 # Random subset of data per tree
  colsample_bytree = 0.8,          # Random subset of features per tree
  gamma = 1,                       # Minimum loss reduction for splits
  min_child_weight = 5             # Prevent overfitting to small groups
)

set.seed(123)
xgb_model <- xgb.train(
  params,
  data = dtrain,
  nrounds = 1000,                  # Large number (early stopping will handle)
  watchlist = list(train = dtrain),
  early_stopping_rounds = 50,      # Stop if no improvement for 50 rounds
  print_every_n = 10
)
```

```{r}
dtest <- xgb.DMatrix(as.matrix(test_data[, predictors]))
test_data$pred_diff_log <- predict(xgb_model, dtest)

# Convert to actual price predictions
test_data <- test_data %>%
  mutate(
    pred_log_price = last_log_price + cumsum(pred_diff_log),  # Only if modeling differences
    pred_price = exp(pred_log_price)
  )
```

```{r}
ggplot(test_data, aes(x = Time)) +
  geom_line(aes(y = month_Price, color = "Actual")) +
  geom_line(aes(y = pred_price, color = "Predicted")) +
  labs(title = "XGBoost: Actual vs. Predicted Price",
       x = "Time", y = "Price") +
  scale_color_manual(values = c("Actual" = "black", "Predicted" = "red")) +
  theme_minimal()
```


```{r}
# xgb = XGBClassifier(random_state=42)
# xgb.fit(predictors, target)
```









