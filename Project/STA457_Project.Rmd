---
title: "STA457 Project"
author: "Xing Yu Wang"
date: "2025-03-29"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", out.width = "75%")
```

```{r, message=FALSE}
# install.packages("forecast")
# install.packages("astsa")

library(dplyr)
library(tidyverse)
library(readr)
library(lubridate)
library(forecast)
library(astsa)
library(tseries)
library(mgcv)
library(vars)
```


# 1. EDA
```{r}
price = read.csv("./Daily Prices_ICCO.csv")
weather = read.csv("./Ghana_data.csv")
USD_GHS_Historical_Data = read.csv("./USD_GHS Historical Data.csv")
```

## 1.1 Clean Data
```{r}
weather <- weather |> dplyr::select(DATE, TAVG)
exchangerate <- USD_GHS_Historical_Data |> dplyr::select(Date, Price)
```

```{r}
colnames(price)[colnames(price) == 'ICCO.daily.price..US..tonne.'] <- 'Daily_Price'
colnames(weather)[colnames(weather) == 'DATE'] <- 'Date'
colnames(weather)[colnames(weather) == 'TAVG'] <- 'Avg_Temp'
colnames(exchangerate)[colnames(exchangerate) == 'Price'] <- 'exchange_rate'
```

## 1.2 Check duplicated values
```{r}
price |> group_by(Date) |> filter(n() > 1) |> ungroup()
```

```{r}
price <- price |> filter(!(Date == "31/01/2024" & Daily_Price == "10,888.05"))
price <- price |> filter(!(Date == "30/01/2024" & Daily_Price == "10,676.42"))
price <- distinct(price)
```

## 1.3 Convert to Time Series Data
### 1.3.1 price Dataset
```{r}
price$Date <- as.Date(price$Date, format="%d/%m/%Y")
price$Daily_Price <- as.numeric(gsub(",", "", price$Daily_Price))
price_month <- price |> mutate(Time = floor_date(Date, "month")) |> group_by(Time) |> 
  summarise(month_Price = mean(Daily_Price, na.rm = TRUE)) |> ungroup()
```

```{r}
summary(price)
```

```{r}
price_ts <- ts(price_month$month_Price, start = c(1994, 11), end = c(2024, 11), frequency = 12)
```

```{r}
plot(price_ts, main="Monthly Price Time Series", ylab="Price", xlab="Time")
```

```{r}
acf2(price_ts, 50)
```

```{r}
ndiffs(price_ts)
```

```{r}
price_month$price_log <- log(price_month$month_Price)
adf.test(price_month$price_log)
```

```{r}
acf2(price_month$price_log, 50)
```

Hence, we want to difference the price data.

```{r}
diff_log_price = diff(price_month$price_log)
ts.plot(diff_log_price, main = "Log Differenced Price Data", ylab = "Log Differenced Price")
```

```{r}
adf.test(diff_log_price)
```

```{r}
acf2(diff_log_price, 50)
```

### 1.3.2 ghana Dataset
```{r}
weather$Date <- as.Date(weather$Date)
weather$Avg_Temp <- as.numeric(gsub("", "", weather$Avg_Temp))
weather_month <- weather |> mutate(Time = floor_date(Date, "month")) |> group_by(Time) |> 
  summarise(Avg_Temp = mean(Avg_Temp, na.rm = TRUE)) |> ungroup()
```

```{r}
summary(weather_month)
```

```{r}
weather_ts <- ts(weather_month$Avg_Temp, start = c(1994, 11), end = c(2024, 11), frequency = 12)
```

```{r}
ts.plot(weather_ts, main="Monthly Average Temperature Time Series", ylab="Temperature", xlab="Time")
```

### 1.3.3 exchange Data
```{r}
exchangerate$Date <- as.Date(exchangerate$Date)
exchangerate$exchange_rate <- as.numeric(gsub("", "", exchangerate$exchange_rate))
rate_month <- exchangerate |> mutate(Time = floor_date(Date, "month")) |> group_by(Time) |> 
  summarise(exchange_rate = mean(exchange_rate, na.rm = TRUE)) |> ungroup()
```

```{r}
summary(exchangerate)
```

```{r}
rate_ts <- ts(rate_month$exchange_rate, start = c(1994, 11), end = c(2024, 11), frequency = 12)
```

```{r}
ts.plot(rate_ts, main="Monthly Average Exchange Rate Time Series", ylab="Exchange Rate (USD/GHS)", xlab="Time")
```

```{r}
par(mfrow=c(3,1), mar = c(3, 4, 2, 2))
# price
plot(price_ts, main="Monthly Price Time Series", ylab="Price", xlab="Time")
#temperature
ts.plot(weather_ts, main="Monthly Average Temperature Time Series", ylab="Temperature", xlab="Time")
# exchange rate
ts.plot(rate_ts, main="Monthly Average Exchange Rate Time Series", ylab="Exchange Rate (USD/GHS)", xlab="Time")
```

## 1.4 Time series plots for data
```{r}
ggtsdisplay(price_ts, main="Time series plot for Monthly World Cocoa Price")
```


```{r}
ggtsdisplay(weather_ts, main="Time series plot for Monthly Average Temperature")
```

```{r}
ggtsdisplay(rate_ts, main="Time series plot for Monthly Average Exchange Rate(USD/GHS)")
```

```{r}
par(mfrow=c(3,1), mar = c(3, 4, 2, 2))
# price
plot(price_ts, main="Monthly Price Time Series", ylab="Price", xlab="Time")
#temperature
ts.plot(weather_ts, main="Monthly Average Temperature Time Series", ylab="Temperature", xlab="Time")
# exchange rate
ts.plot(rate_ts, main="Monthly Average Exchange Rate Time Series", ylab="Exchange Rate (USD/GHS)", xlab="Time")
```
## 1.5 Combine and Split data
```{r}
data <- price_month |> left_join(weather_month, by = "Time") |> left_join(rate_month, by = "Time")
data <- data |> mutate(log_price = log(month_Price), diff_log_price = 
                         c(NA, diff(price_month$price_log))) |> drop_na()
data <- data |> dplyr::select(Time, Avg_Temp, exchange_rate, diff_log_price, log_price, month_Price)

data$Time <- as.Date(data$Time)
```

```{r}
data <- data[order(data$Time), ]
cutoff <- floor(0.7 * nrow(data))
trainSet <- data[1:cutoff, ]
testSet <- data[(cutoff+1):nrow(data), ]
```

```{r}
data_train_ts <- ts(trainSet$diff_log_price, frequency = 12)
```

## 1.6 Stationarity check and Decomposition
```{r}
adf.test(data$month_Price)
```

```{r}
adf.test(data$log_price)
```


```{r}
adf.test(data$diff_log_price)
```

Since only the diff_log_price is stationary, we choose differenced monthly log price when fitting the model.

```{r}
diff_price_ts <- ts(data$diff_log_price, frequency = 12)
autoplot(decompose(diff_price_ts, type="additive")) +
  ggtitle("Decomposition of Differenced Log Price Time Series") +
  theme_minimal()
```




# 2. Method
## 2.1 ETS Model
ETS is a purely univariate model and cannot directly handle external regressors.

### 2.1.1 Fit Model
```{r}
ets_model <- ets(data_train_ts)
ets_zmodel <- ets(data_train_ts, model = "ZZZ") # Automatically selects best model
summary(ets_model)
summary(ets_zmodel)
```
ETS(A,N,N) is the best model.

### 2.1.2 Forecasting and Plotting
```{r}
# Plot using log differenced price
data_test_ts <- ts(testSet$diff_log_price, start = end(data_train_ts) + c(0,1), 
                   frequency = 12)

h <- nrow(testSet)
forecast_ets <- forecast(ets_model, h = h)

autoplot(forecast_ets) + autolayer(data_test_ts, series = "Actual", color = "red")
```
The red line is the observed actual values. The forecasted values are the central blue line within the blue shaded prediction intervals.

```{r}
last_log_price <- tail(trainSet$log_price , 1)
forecasted_log_price <- cumsum(forecast_ets$mean) + last_log_price

# Convert back to actual price
forecasted_price <- exp(forecasted_log_price)

actual_price <- exp(testSet$log_price)
```

```{r}
data_test_ts <- ts(testSet$diff_log_price, start = end(data_train_ts) + c(0,1), 
                   frequency = 12)

forecast_ets_ts <- ts(forecasted_price, start = start(data_test_ts), frequency = 12)
actual_ets_ts <- ts(actual_price, start = start(data_test_ts), frequency = 12)
```

```{r}
# Plot using actual price
autoplot(forecast_ets_ts, series = "Predicted") + 
  autolayer(actual_ets_ts, series = "Actual", color = "blue") +
  ggtitle("Forecast vs Actual Prices") +
  ylab("Price") +
  xlab("Time") +
  theme_minimal()
```

## 2.2 ARIMAX Model

Recall that in Section 1.3.1, we have tested the acf and adf.test, and determined that we would be using the differenced price data. To fit the trainset, we evaluate p and q for ARIMA model.

```{r}
adf.test(trainSet$log_price)
```

Next, we check if applying 1st differencing is good enough
```{r}
adf.test(diff(trainSet$month_Price))
```
P-value is smaller than 0.01 for differenced log price, and we are

```{r}
acf2(trainSet$diff_log_price)
```

### 2.2.1 Fit ARIMAX Model
```{r}
xreg_matrix <- cbind(trainSet$Avg_Temp, trainSet$exchange_rate)
colnames(xreg_matrix) <- c("Avg_Temp", "exchange_rate")
arimax_model <- Arima(trainSet$log_price, order=c(1,1,1), xreg = xreg_matrix)
summary(arimax_model)
```

```{r}
AIC(arimax_model)
```

```{r}
checkresiduals(arimax_model)
```

```{r}
qqnorm(arimax_model$residuals)
qqline(arimax_model$residuals, col="red")
```

Fail to reject $H_0$, hence residuals of this plot do not show significant autocorrelation.
- QQ-plot shows: ....
- ACF shows: ...
- Residuals shows: ...

```{r}
arimax_train_ts <- ts(trainSet$log_price, start = start(min(trainSet$Time)), frequency = 12)
arimax_fitted_ts <- ts(fitted(arimax_model), start = start(min(trainSet$Time)), frequency = 12)
plot(arimax_train_ts, type='l', col='black', main="ARIMAX: Train Set Log Prices vs Fitted", 
     ylab="Log Price", xlab="Time")
lines(arimax_fitted_ts, col='red')
```
The ARIMAX model fit the trainSet very accurately.

### 2.2.2 Forecasting With ARIMAX Model
Next we try to fit this ARIMAX model to testing set.
```{r}
forecast_arimax_xreg <- cbind(testSet$Avg_Temp, testSet$exchange_rate)
colnames(forecast_arimax_xreg) <- c("Avg_Temp", "exchange_rate")
forecast_arimax <- forecast(arimax_model, xreg=forecast_arimax_xreg, h=nrow(testSet))
```

Then we convert the log prediction back to original price.

```{r}
start_year <- format(min(testSet$Time), "%Y")
start_month <- format(min(testSet$Time), "%m")
start_arimax_test = c(as.numeric(start_year), as.numeric(start_month))

actual_price_arimax <- testSet$month_Price
forecasted_price_arimax <- exp(forecast_arimax$mean)
forecasted_arimax_lower95 <- exp(forecast_arimax$lower[,2])
forecasted_arimax_lower80 <- exp(forecast_arimax$lower[,1])
forecasted_arimax_upper95 <- exp(forecast_arimax$upper[,2])
forecasted_arimax_upper80 <- exp(forecast_arimax$upper[,1])

actual_arimax_ts <- ts(actual_price_arimax, start = start_arimax_test, frequency = 12)
forecast_arimax_ts <- ts(forecasted_price_arimax, start = start_arimax_test, frequency = 12)
forecasted_arimax_lower80_ts <- ts(forecasted_arimax_lower80, start = start_arimax_test, frequency = 12)
forecasted_arimax_lower95_ts <- ts(forecasted_arimax_lower95, start = start_arimax_test, frequency = 12)
forecasted_arimax_upper80_ts <- ts(forecasted_arimax_upper80, start = start_arimax_test, frequency = 12)
forecasted_arimax_upper95_ts <- ts(forecasted_arimax_upper95, start = start_arimax_test, frequency = 12)


# Plot with proper transformation
autoplot(actual_arimax_ts, series="Actual Price") +
  autolayer(forecast_arimax_ts, series="Forecasted Price") +
  autolayer(forecasted_arimax_lower95_ts, series="95% Lower Bound", linetype="dashed") +
  autolayer(forecasted_arimax_lower80_ts, series="80% Lower Bound", linetype="dashed") +
  autolayer(forecasted_arimax_upper80_ts, series="80% Upper Bound", linetype="dashed") +
  autolayer(forecasted_arimax_upper95_ts, series="95% Upper Bound", linetype="dashed") +
  ggtitle("ARIMAX Forecast (Transformed to Original Scale)") +
  ylab("Actual Price") +
  xlab("Time") +
  theme_minimal()
```


```{r}
accuracy(arimax_model)
```

```{r}
accuracy(forecast_arimax, testSet$log_price)
```

```{r}
accuracy(forecast_arimax$mean, testSet$log_price)
accuracy(forecast_arimax_ts, actual_arimax_ts)
```

80% lower and upper bound from forecasts create a tighter bounds for the forecasting the actual price as shown in graph. However, since our price data is non-stationary, and there is a sudden increase towards the end, the ARIMAX model, which relies on historical patterns, struggles to capture this trend, leading to poorer performance on the test set.

```{r include=FALSE}
## 2.3 VAR model (not using this part)
# Not a very reliable model for our dataset :).

# Prepare the data: price, exchange rate, and average temperature
# var_data <- trainSet %>% dplyr::select(where(is.numeric))
# VARselect(var_data, lag.max = 10, type = "const")
# var_model <- VAR(var_data, p=1, type="const")
# summary(var_model)
```

```{r include=FALSE}
# var_data <- trainSet %>% dplyr::select(where(is.numeric))
# xreg_matrix <- as.matrix(cbind(var_data$Avg_Temp, var_data$exchange_rate))
# adf.test(var_data$diff_log_price)
# armax_model <- auto.arima(var_data$diff_log_price, xreg = xreg_matrix, d=0)
# summary(armax_model)
```

```{r include=FALSE}
# plot(var_data$diff_log_price, type="l")
```

## 2.5 GAM Model
### 2.5.1 Fit Model
#### 2.5.1.1 Basic Model
```{r}
# Uses simple smoothing splines for variables
trainSet$Time_num <- as.numeric(trainSet$Time)

gam_basic <- gam(diff_log_price ~ s(Time_num) + s(Avg_Temp) + s(exchange_rate), 
                 data = trainSet, method = "REML")
```

```{r}
gam.check(gam_basic)
```

#### 2.5.1.2 Complex Model
```{r}
# Fit GAM model with smooth trend, random effects, and seasonality
trainSet$dateInt = as.integer(trainSet$Time)
trainSet$monthFac <- factor(format(trainSet$Time, "%m"))
gam_complex <- gam(diff_log_price ~ s(dateInt, k = 100) + s(monthFac, bs = "re") + 
                     sinpi(dateInt / 182.625) + cospi(dateInt / 182.625) + 
                     sinpi(dateInt / 91.3125) + cospi(dateInt / 91.3125) + 
                     s(Avg_Temp) + s(exchange_rate), data = trainSet, 
                   method = "REML", optimizer = "efs")
```

```{r}
summary(gam_basic)
summary(gam_complex)
```

```{r}
plot(gam_complex, pages = 1, shade = TRUE)
```

```{r}
gam.check(gam_complex) 
```






